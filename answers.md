### 1. Основные различия между unittest и pytest

**unittest** (встроенный модуль Python):
- Наследуется от `unittest.TestCase`
- Требует использования методов `assert*`
- Более многословный синтаксис
- Запуск через `unittest.main()`
- Требует организации в классы
- Поддержка фикстур через `setUp()`/`tearDown()`

**pytest** (сторонняя библиотека):
- Использует обычные функции (не требует классов)
- Лаконичные assert-выражения (не нужны спец. методы)
- Автоматическое обнаружение тестов
- Богатые возможности параметризации
- Плагины и расширения (например, для покрытия кода)
- Более информативные сообщения об ошибках

Пример сравнения:
```python
# unittest
self.assertEqual(result, expected)

# pytest
assert result == expected
```

### 2. Важность автоматических тестов

**Причины использования:**
1. **Раннее обнаружение ошибок** - тесты выявляют баги до продакшена
2. **Регрессионная защита** - гарантия, что новые изменения не ломают существующий функционал
3. **Документирование кода** - тесты показывают, как должен работать код
4. **Упрощение рефакторинга** - уверенность при изменении структуры кода
5. **Сокращение ручного тестирования** - автоматизация повторяющихся проверок

> По данным исследования Microsoft, автоматические тесты снижают количество дефектов на 40-80%

### 3. Виды ассертов

**В unittest** (полный список в [документации](https://docs.python.org/3/library/unittest.html)):
```python
self.assertEqual(a, b)        # a == b
self.assertNotEqual(a, b)     # a != b
self.assertTrue(x)            # bool(x) is True
self.assertFalse(x)           # bool(x) is False
self.assertIsNone(x)          # x is None
self.assertIn(a, b)           # a in b
self.assertRaises(Exc, func)  # func() raises Exc
```

**В pytest** (использует стандартные операторы Python + дополнения):
```python
assert x == y
assert x != y
assert x in collection
assert not condition
assert x is None
with pytest.raises(ExpectedException):
    function()
```

Pytest также предоставляет дополнительные проверки через плагины.

### 4. `@pytest.mark.parametrize`

Это декоратор для **параметризованного тестирования**, позволяющий запускать один тест с разными наборами данных.

Пример:
```python
import pytest

@pytest.mark.parametrize("input,expected", [
    ([1, 2, 3], 2),
    ([0, 0, 0], 0),
    ([-1, 0, 1], 0),
])
def test_average(input, expected):
    assert calculate_average(input) == expected
```

Преимущества:
- Уменьшает дублирование кода
- Четко показывает все тестовые случаи
- Генерирует отдельный тест для каждого набора параметров

### 5. Когда предпочесть pytest

**Выбирайте pytest, когда нужно:**
1. **Быстро написать тесты** - меньше boilerplate-кода
2. **Использовать продвинутые фичи**:
   - Параметризованные тесты
   - Плагины (pytest-cov, pytest-xdist)
   - Фикстуры с зависимостями
3. **Получить детальные отчеты** - pytest дает более информативные сообщения об ошибках
4. **Тестировать сложные сценарии** - встроенная поддержка асинхронности, моков и т.д.

**Unittest может быть лучше для:**
- Легационных проектов, уже использующих unittest
- Когда требуется строгая структура тестов (например, в больших командах)
- Если нельзя устанавливать сторонние зависимости

**Статистика использования** (из опроса Python Developers Survey 2021):
- pytest - 84%
- unittest - 72%
- nose - 8%

Пример миграции с unittest на pytest:
```python
# Было (unittest)
class TestClass(unittest.TestCase):
    def test_func(self):
        self.assertEqual(func(2), 4)

# Стало (pytest)
def test_func():
    assert func(2) == 4
```